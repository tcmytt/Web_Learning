1.SPA/MPA :
ReactJS là 1 thư viện giúp tạo SPA

SPA : Single-Page Application , CSR : Client side rendering 
    + Cách tiếp cận hiện đại hơn 
    + Nhanh hơn trong quá trình sử dụng
    + Không yêu cầu tải lại trang trong quá trình sử dụng
    + Phần lớn tài nguyên được tải trong lần đầu
    + Trang chỉ tải thêm dữ liệu mới khi cần(call api)
    + Có Front-end riêng biệt
    + SPA ko thân thiện với SEO như MPA
    + Khả năng tái sử dụng code
    + Phụ thuộc hoàn toàn vào JS

MPA : Multi-Page Application , SSR : Server side rendering 
    + Cách tiếp cận cổ điển 
    + Yêu cầu tải lại trang trong quá trình sử dụng (Link)
    + Chậm hơn, tải lại trang khi truy cập, chuyển hướng
    + Fornt-end Back-end phụ thuộc nhau

SPA : Dùng khi quan tâm trải nghiệm người dùng, nâng cấp, mở rộng trong tương lai,
    Tốn ít chi phí hạ tầng do JS tự xây dựng trên clien, tốn nhiều chi phí xây dựng app do chia team viết api,
MPA : Đơn giản hơn, dễ tạo, vì chuyển trang lại request lên sv nên tốn nhiều chi phí hạ tầng

2.Cách ReactJS render giao diện người dùng :
<script>
    const h1 = document.createElement('h2')

    // h1 là 1 obj
    h1.innerText = 'Hello'
    h1.id = 'aaa'
    h1.className='ssss test' // Là thuộc tính
    // Không dùng h1.class do class trùng với tên bên hướng đối tượng
    h1.style.color = 'red'
    h1.style = 'color : green; font-size : 20px'
    Object.assign(h1.style,{
        color: 'blue',
        backgroundColor:'#333' // Không dùng background-Color mà dùng kiểu lạc đà
    })

    // Gán h1 làm con của thẻ body
    document.body.appendChild(h1)
</script>

3. Cách thêm React vào website. Github, NPMJS, UNPKG
- NPMJS : Node package Manager JavaScript
- UNPKG : Unpakage NPM | unpkg.com/:package@:version/:file
VD : unpkg.com/react@17.0.2/index.js
- cdn : content delivery network
<script crossorigin src="https://unpkg.com/react@17.0.2/umd/react.production.min.js"></script>

4.React.createElement()
- class đổi thành className
    // DOM
    const h1DOM = document.createElement('h1')

    h1DOM.id = "ul-id"
    ulDom.style = "color: red; font-size : 30px"
    h1DOM.title = 'HELLO'
    h1DOM.className = 'heading'
    h1DOM.innerText = 'hello guys'
    document.body.appendChild(h1DOM)

    const ulDOM = document.createElement('ul')
    const liDOM1 = document.createElement('li')
    liDOM1.innerText = 'Javascript'
    const liDOM2 = document.createElement('li')
    liDOM2.innerText = 'ReactJS'
    ulDOM.appendChild(liDOM1)
    ulDOM.appendChild(liDOM2)
    document.body.appendChild(ulDOM)


    // React
    // React.createElement(typeTag, props, children1, children-n)
    const h1React = React.createElement('h1', {
        title : 'hello',
        className : "heading",
    }, 'Heelo guy! ')
    // Tự tạo 1 children trong props | children : 'Heelo guy! '
    const ulReact = React.createElement(
        'ul',
        {
            id : "ul-id",
            style:{color : "red"; font-size : "30px"}
        },
        React.createElement('li', {id : "li-1"}, 'javascript'),
        React.createElement('li', null, 'reactJs')
    )

- LƯU Ý : style nhận obj

5.ReactDOM : Render ra web
- Chỉ dùng đc khi đã có 
<script crossorigin src="https://unpkg.com/react@17.0.2/umd/react.production.min.js"></script>
- Thư viện React - Dom : Được tách ra từ React từ lâu về trước
<script crossorigin src="https://unpkg.com/react-dom@17.0.0/umd/react-dom.production.min.js"></script> 
- React-Native : Code trên androi, ios
- Render bị đè lên nhau

@17
ReactDOM.render(ReactElement, root)

@18
const tmp = ReactDOM.createRoot(root)
tmp.render(h1React);

6. JSX 
JSX : JavaScript XML
XML : HTML là mở rộng của XML
Babel : Thư viện javascript dùng để chuyển từ JSX sang JS, ES6 -> ES5
<script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
Lưu ý cần viết vào : 
+ type="text/babel", 
+ {} là code javascript 
+ {{...}} là obj

    <script type="text/babel">
    const courses = [
            {
                name: "HTML, CSS"
            },
            {
                name: "Responsive"
            },
            {
                name:"ReactJS"
            }
        ]
            
    const ul1 = <ul>
           {courses.map((item,index) => {
                return <li key={index}>{item.name}</li>
            })}
        </ul>
    </script>

7. JSX render Arrays
    const ul1 = <ul>
           {courses.map((item,index) => {
                return <li key={index}>{item.name}</li>
            })}
        </ul>

- Không thể đưa 2 heading   :
            <h1>Heading 1</h1>    
            <h1>Heading 2</h1>   
    mà không có bao quanh, có thể bao bằng div hoặc React.Fragment

    const jsx = <React.Fragment> 
            <h1>Heading 1</h1>    
            <h1>Heading 2</h1>    
        </React.Fragment>

8.React element types strings("div","h2"...)/func,class Trong bable
- React.createElement(type,props,children...)

- Hooks
- Func/Class component type trong babel
- Luôn viết hoa chữ cái đầu Hàm trong babel , viết kiểu camel case
- ý nghĩa : 
VD: 
    function Header () {
        return (
            <div className="header">Header</div>
        )
    }

// Class
    class Content extends React.component {
        render(){
            return (
                <div className="content"> Content </div>
            )
        }
    }

    const app = (
        <div className="wrapper">
            <Header></Header>
            <Content />
            <div className = "content"> Content</div>
        </div>
    )

9.Props react element
- React elements: 
+ Dùng props giống attribute thẻ html
+ 2 props class , for => ClassName, htmlFor (Trong thẻ label)
+ Tuân theo quy ước có sẵn
- React components
+ Sử dụng props giống đối số cho component, là kiểu obj không cần {} hay dấu , thay : bằng = ;do babel tự xử lí dc
+ Tự do đặt tên props: Đặt theo camelCase, Có thể bao gồm gạch ngang

+ Props "key" là props đặc biệt
+ Props cơ bản là đối số của component
=> Props có thể có thể là bất cứ kiểu dư liệu gì
+ Sử dụng destructuring
<script type="text/babel">

        //PostItem.js 
        // Dùng destructuring để đặt default
        function PostItem({
            callback = () => {},
            tiltle,
            des,
            img
        }) {

            if (typeof callback === "function") {
                callback(Math.random());
            }
//            callback() 
            return (
                <div className="post-item">
                    <h2>
                        {tiltle} Tương tác {des}
                    </h2>
                    <img src={img} alt="" srcset="" />
                    <label htmlFor="email">Email</label>
                    <input id="email" type="text" />
                </div>
            );
        }

        //App.js 
        function App() {
            return (
                <div id="wrapper">
                    HELLO !
                    <PostItem tiltle="Ahr uv tur" img="data:image/jpeg;base64,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"
                        des="tuyệt vời" data={[{ a: 1 }, { b: 2 }]} callback={(tmp) => { console.log(tmp); }} />
                </div>
            );
        }

        //index.js import app vào 
        ReactDOM.render(
            <App />, document.getElementById("root"));
        // <App /> Dùng khi lấy luôn chưa qua bước tạo
    </script>

10. DOM event
- onclick là code thuần nhưng trong babel là onClick, viết theo kiểu camel
        function VD2(){
            function App(){
                return (
                    <div id = "wrapper">
                        <button 
                            onClick={() => console.log(Math.random())}
                            onDoubleClick={(e) => console.log(e.target)}
                            >   Click me!
                        </button>
                    </div>
                )
            }

            ReactDOM.render(<App/> , document.getElementById("root"))
        }

11. Quy ước về component
- UI component
- Container component
- Boolean không render do đó dùng boolean để check điều kiện render

function App(){
                const type = "Input"
                const Cpn = Form[type]

                let firstAccess = true

                return (
                    <div id = "wrapper">
                        {firstAccess && <h1> Welcome to F8 </h1>}
                        <Cpn />
                        <Form.CheckBox />
                        <Button
                            title = " clickMe "
                            onClick = {() => console.log(Math.random())}
                            //href = "https://www.youtube.com"
                        />
                    </div>
                )
            }

            ReactDOM.render(<App   title = "hello" /> , document.getElementById("root"))

        }

12.Children props? Render props?
- props trong jsx : 
<YourComponent 
    isPrimary
    primary ={true}
    propName1 = "String literals"
    propName2 = {expression}
    />

- isPrimary không truyền gì cả thì vẫn là biến dạng boolean giá trị true
- primary ={true} là truyền vào 1 biến primary có giá trị true
- expression : if else, switch case sẽ ko truyền dc

- Spread/ Rest props :
function Input({ label, ...inputProps }) {
                return (
                    <div>
                        <label> {label} </label>    
                        <input {...inputProps} />
                    </div>
                )
            }

function App(){
                return(
                    <div id= "wrapper">
                        <Input  
                            label ="fullName"
                            placeholder = "Enter Name ..."
                            onFocus= {() => console.log(Math.random())}
                        ></Input>    
                    </div>
                )
            }

- Children props : children là thằng text element (HELLOOOO)
function App(){
                return(
                    <div id= "wrapper">
                        <Input> HELLOOO</Input>    
                    </div>
                )
            }
- Ngoài text có thể dùng { } truyền biểu thức

13. NodeJs 
- là JavaScript Runtime : môi trường độc lập để chạy javascript
- nodejs npm webpack

Tạo dự án thủ công . Vào thư mục khởi tạo dự án
Bc1 : npm init
- Set up dự án
Bc2 : npm install webpack webpack-cli --save-dev
- cài đặt 2 thư viện là webpack và webpack-cli
- flag --save-dev để đánh dấu 2 thư viện này chỉ dùng trong khi phát triển, khi dự án đẩy lên production sẽ không có các thư viện này
- Sau khi chạy lệnh, webpack và webpack-cli được thêm vào devDependencies (Thư viện dùng cho phát triển) (Do dùng flag--save-dev)
Bc3 : npm install react@17.0.2 react-dom@17.0.2 --save
- --save để thêm các thư viện được cài vào phần dependencies trong package.json
- dependencies là các thư viện được sử dụng trong dự án, bao gồm cả development & production. 
- Từ phiên bản NPM 5 trở đi thì --save được thêm vào mặc định, nếu bạn đang sử dụng NPM >= 5 thì có thể không cần --save.
Bc4: npm install @babel/core babel-loader @babel/preset-env @babel/preset-react --save-dev
- babel-core: Chuyển đổi ES6 về ES5
- babel-loader: Cho phép chuyển các files Javascript sử dụng Babel & Webpack
- babel-preset-env: Giúp sử dụng Javascript mới nhất trên nhiều môi trường khác nhau (nhiều trình duyệt khác nhau). Gói này đơn giản là support truyển đổi ES6, ES7, ES8, ES... về ES5.
- babel-preset-react: Hỗ trợ chuyển đổi JSX về Javascript
Bc5 : Tạo file public/index.html
- gõ ! và nhấn Tab
- tạo #root element:
Bc6 : Tạo src/index.js
import React from 'react' // nạp thư viện react
import ReactDOM from 'react-dom' // nạp thư viện react-dom

// Tạo component App
function App() {
    return (
        <div>
            <h1>Xin chào anh em F8!</h1>
        </div>
    )
}

// Render component App vào #root element
ReactDOM.render(<App />, document.getElementById('root'))

Bc7 : npm install css-loader style-loader --save-dev
- Cấu hình web pack

Bc8: Tạo file webpack.config.js trong thư mục gốc (Ngang hàng package.json)
const path = require("path");

module.exports = {
  entry: "./src/index.js", // Dẫn tới file index.js ta đã tạo
  output: {
    path: path.join(__dirname, "/build"), // Thư mục chứa file được build ra
    filename: "bundle.js" // Tên file được build ra
  },
  module: {
    rules: [
      {
        test: /\.js$/, // Sẽ sử dụng babel-loader cho những file .js
        exclude: /node_modules/, // Loại trừ thư mục node_modules
        use: ["babel-loader"]
      },
      {
        test: /\.css$/, // Sử dụng style-loader, css-loader cho file .css
        use: ["style-loader", "css-loader"]
      }
    ]
  },
  // Chứa các plugins sẽ cài đặt trong tương lai
  plugins: [
  ]
};


Bc9 : Tạo file .babelrc trong thư mục gốc (Ngang hàng package.json)
- Dùng cấu hình cho thư viện Babel.
{
    "presets": [
        "@babel/preset-env",
        "@babel/preset-react"
    ]
}

Bc10 : Thêm nội dung cho package JASON
"scripts": {
    ...
    "start": "webpack --mode development --watch",
    "build": "webpack --mode production"
}

- Dùng để chạy : npm start , npm run build 
- lưu ý ngoài npm start tất cả cần thêm run

Chạy dự án
Bc1 : npm start
- Tạo file bundle.js trong thư mục build.
- Nội dung trong build chính là code của file src/index.js đã được Babel chuyển đổi, bạn có thể mở ra để quan sát.
- Bạn sẽ thấy có rất nhiều code trong này vì nó bao gồm cả code của những thư viện chúng ta đã import như: react và react-dom.

Bc2 : npm install html-webpack-plugin --save-dev
- Cài thư viện để tự link file js
- Cấu hình Webpack để thêm html-webpack-plugin vào dự án
Tại webpack.config.js :
Thêm vào đầu file :
const HtmlWebpackPlugin = require("html-webpack-plugin");

Thêm vào điểm thích hợp :
 plugins: [
    new HtmlWebpackPlugin({
      template: "./public/index.html"
    })
  ]

Cài webpack-dev-server :
Bc1 : npm install webpack-dev-server --save-dev
- Dùng thay thế live-sever 

Bc2 : "start": "webpack-dev-server --mode development --open --hot",
Sửa lại cấu hình 

Cài thư viện mới nhất :
npm i react@latest react-dom@latest
npm i react@17.0.2 react-dom@17.0.2

14. Tạo dự án với create-react-app
Cài global npm : npm install -g npm
- Do bản trước chỉ cài trong node

npm tại :
C:\Users\<Tên người dùng>\AppData\Roaming\npm
C:\Program Files\nodejs\node_modules\npm

sau đó cài : npx create-react-app tiktok

15. NPM, NPX và YARN
Lưu ý : Luôn bật development sever (npm start || yarn start)

NPM : Với linux cần sudo
- Project scope  : Cài vào dự án cụ thể
    + npm i react react-dom   -> Lưu vào dependencies , i là install
    + npm i react react-dom --save-dev -> Lưu vào devDependencies
    + npm uninstall react react-dom
    + npm i create-react-app   
    + npm i : Cài lại file
    // Cài thư viện create-react-app   

- Global scope   : Cài vào máy tính ( thư mục user ổ C)
    + npm i -g create-react-app
    + npm uninstall -g create-react-app 

NPX :Node => NPM, NPX
    // Thực thi file bin trong thư viện
    npx create-react-app tiktok
    // Vào file bin trong node_modules tìm file create-react-app thực thi,
    // tìm từ project sang global không thấy lên npm tải về để thực thi, thực thi xong xoá bỏ luôn

YARN và NPM : node package Manager(Trình quản lí gói) và Yet Another resource Negotiator(Trình quản lí gói khác)
Yarn giống npm nhưng nhanh hơn và tốn bộ nhớ hơn 1 ít
Cài Yarn : npm i -g yarn 
Bỏ -g cũng dc g là global

Cài đặt gói:
Yarn: yarn add <tên-gói>
npm: npm install <tên-gói>

Cài đặt gói toàn cục (để sử dụng gói một cách toàn cục trên hệ thống):
Yarn: yarn global add <tên-gói>
npm: npm install -g <tên-gói>

Cài đặt gói cục bộ (để sử dụng gói chỉ trong dự án cụ thể):
Yarn: yarn add <tên-gói> --dev hoặc yarn add <tên-gói> --save-dev
npm: npm install <tên-gói> --save-dev

Xóa gói:
Yarn: yarn remove <tên-gói>
npm: npm uninstall <tên-gói>

Cập nhật gói:
Yarn: yarn upgrade hoặc yarn upgrade <tên-gói>
npm: npm update hoặc npm update <tên-gói>

Cài đặt tất cả các gói từ file package.json:
Yarn: yarn
npm: npm install

Kiểm tra phiên bản của gói:
Yarn: yarn list --pattern <tên-gói>
npm: npm show <tên-gói> version

Cài đặt phiên bản cụ thể của gói:
Yarn: yarn add <tên-gói>@<phiên-bản>
npm: npm install <tên-gói>@<phiên-bản>

16. CRA Folder Structure

17. Hooks (Gắn, móc)
- Là hàm trong reactJs , có từ 16.8.0
import {
    useState,
    useEffect,
    useLayoutEffect,
    useRef,
    usememo,
    useReducer,
    useContext,
    useImprerativeHandle,
    useDebugValue,
} from 'react'

- Hooks chỉ dùng trong function component
- Component đơn giản, dễ hiểu

18. useState()
- Dùng khi muốn dữ liệu thay đổi giao diện thay đổi theo tự động
import {useState} from 'react'
- Thêm vào function component :
function Component (){
    const [state, setState] = useState(initState)
    ...
}

- Return ra mảng 2 phần tử state và setState 
- state là initState , còn setState là hàm dùng để set lại giá trị
- setState nhận hàm, biểu thức
- Lưu ý initState nhận mọi loại giá trị(hàm thì là giá trị return) và chỉ load 1 lần nên logic phức tạp nên để vào hàm trong initState
- Do mỗi lần chạy setState là lại load lại 1 lần nên nếu để ngoài thì gây nhiều tính toán không cần thiết
VD1:
import {useState} from 'react'

function App() {
  const [state, setState] = useState(1);


  let handleIncrease =() => {
    // Không áp dụng liên tục dù gọi 3 lần
    setState(state + 1)
    setState(state + 1)
    setState(state + 1)

    // Áp dụng liên tục gọi cả 3 lần
    setState(prevState => prevState +1 )
    setState(prevState => prevState +1 )
    setState(prevState => prevState +1 )

  }

  let handleUpdate = () =>{
    setState(pre =>{
      // logic

      return {
        //...
      }
    })
  }

  return (
    <div style = {{padding : 20 }} className="App">
      <h1  >{state} </h1>
      <button onClick={handleIncrease}>Increase</button>
    </div>
  );
}

VD2:
function App() {
  const gifts = [
    'CPU i9',
    'Ram 32gb',
    'rgb keyboard'
  ]

  const [gift, setGift] = useState();


  const handleRandom =() => {
    const tmp = Math.floor(Math.random() * gifts.length)
    setGift(gifts[tmp])
  }

  return (
    <div style = {{padding : 20 }} className="App">
      <h1  >{gift || 'Chưa có phần thưởng'} </h1>
      <button onClick={handleRandom}>Phần thưởng</button>
    </div>
  );
}

19. Two-way binding,One-way binding  
- Ràng buộc 1 chiều, ràng buộc 2 chiều
- Reactjs : ràng buộc 1 chiều
- Vuejs : ràng buộc 2 chiều ( V- model)

VD1:
function App() {

  const courses = [
    { id: 1, name: "HTML,CSS", price: 100 },
    { id: 2, name: "JavaScript", price: 120 },
    { id: 3, name: "ReactJS", price: 150 }
  ];   
  
    const [checked, setChecked] = useState([]);
    console.log({ ids: checked });
    const handleCheck = (id) => {
      const isChecked = checked.includes(id);
      setChecked((prev) => {
        if (isChecked) {
          return checked.filter((item) => item !== id);
        } else {
          return [...prev, id];
        }
      });
    };
    const handleSubmit = () => {
      //Call API
    };
    return (
      <div className="App">
        {courses.map((course) => (
          <div key={course.id}>
            <input
              type="checkbox"
              checked={checked.includes(course.id)}
              onChange={() => handleCheck(course.id)}
            />
            {course.name}
          </div>
        ))}
        <button onClick={handleSubmit}>Submit</button>
      </div>
    );
  
  
}

export default App;

Todo List :
import { useState } from "react";

function App() {
  const [job, setJob] = useState("");
  const [jobs, setJobs] = useState(() => {
    const storageJobs = JSON.parse(localStorage.getItem("jobs")) ?? [];
    return storageJobs;
  });

  console.log(job);

  const handleAdd = () => {
    setJobs((prev) => {
      const newJobs = [...prev, job];

      // lưu localStorage khi add
      const jsonJobs = JSON.stringify(newJobs);
      localStorage.setItem("jobs", jsonJobs);
      return newJobs;
    });
    setJob("");
  };

  const handleDelete = (index) => {
    const newJobs2 = jobs.filter((item, id) => id !== index);

    // lưu localStorage khi delete
    const jsonJobs2 = JSON.stringify(newJobs2);
    localStorage.setItem("jobs", jsonJobs2);
    setJobs(newJobs2);
  };

  return (
    <div style={{ padding: 32 }}>
      <input value={job} onChange={(e) => setJob(e.target.value)} />
      <button onClick={handleAdd}>Add</button>

      <ul>
        {jobs.map((job, index) => (
          <li key={index}>
            {job}
            <button onClick={() => handleDelete(index)} style={{ margin: 10 }}>
              Delete
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
}

export default App;

20. Mounted & Unmounted
- Gắn vào và gỡ ra các component
Content.js :
function Content() {
    return (
      <div>
        <h1>hello Anh Em</h1>
      </div>
    );
  }
  
  export default Content;
  
App.js :
import Content from "./Content";
import { useState } from "react";
function App() {
  const [show, setShow] = useState(false);

  return (
    <div style={{ padding: 20 }}>
      <button onClick={() => setShow(!show)}>Show</button>
      {show && <Content />}
    </div>
  );
}

export default App;

21.useEffect hook
- Tạo sideEffect 
import { useEffect , useState } from "react";
import { useEffect } from "react";

- Chung:
- Callback được gọi sau khi component mounted 
- Cleanup function luôn dc gọi trước khi component Unmounted (Là hàm Return của useEffect )

- useEffect (callback) 
+ Gọi callback mỗi khi component re-render
+ Gọi callback sau khi component thêm vào DOM
function Content() {
  const [title, setTitle] = useState('')

    // Viết document.title= title bên ngoài cũng thay đổi dc nhưng ko nên vì  : useEff chạy cuối cùng, mặt ý nghĩa khi dùng
    useEffect(() => {
      document.title= title
    })

    return (
      <input value={title} onChange={e => setTitle(e.target.value)} ></input>
    );

  }

- useEffect (callback, []) 
+ Chỉ gọi callback 1 lần sau khi component mount

- useEffect (callback, [deps])
+ Gọi khi deps thay đổi
VD:
const tabs = ["posts", "comments", "albums", "photos", "todos", "users"];

function Content() {
  const [title, setTitle] = useState("");
  const [posts, setPosts] = useState([]);
  const [type, setType] = useState("posts");

  useEffect(() => {
    console.log(type);
    fetch(`https://jsonplaceholder.typicode.com/${type}`)
      .then((res) => res.json())
      .then((posts) => {
        setPosts(posts);
      });
  }, [type]);

  useEffect(() => {
    
  })

  return (
    <div>
      {tabs.map((tab, index) => (
        <button
          key={index}
          style={
            type === tab
              ? {
                  color: "#fff",
                  backgroundColor: "#333"
                }
              : {}
          }
          onClick={() => setType(tab)}
        >
          {tab}
        </button>
      ))}

      <input value={title} onChange={(e) => setTitle(e.target.value)}></input>
      <ul>
        {posts.map((post) => (
          <li key={post.id}>{post.title || post.name}</li>
        ))}
      </ul>
    </div>
  );
}

VD2: 
import { useEffect, useState } from "react";

const tabs = ["posts", "comments", "albums", "photos", "todos", "users"];

function Content() {
  const [title, setTitle] = useState("");
  const [posts, setPosts] = useState([]);
  const [type, setType] = useState("posts");
  const [gotop, setGotop] = useState(false);

  console.log(type);

  useEffect(() => {
    fetch(`https://jsonplaceholder.typicode.com/${type}`)
      .then((res) => res.json())
      .then((posts) => {
        setPosts(posts);
      });
  }, [type]);

  useEffect(() => {
    const handleScroll = () => {
      if (window.scrollY >= 500) {
        setGotop(true);
      } else {
        setGotop(false);
      }
    };

    window.addEventListener("scroll", handleScroll);
  }, []);

  return (
    <div>
      {tabs.map((tab) => (
        <button
          key={tab}
          style={type === tab ? { color: "#fff", background: "#333" } : {}}
          onClick={() => setType(tab)}
        >
          {tab}
        </button>
      ))}

      <input value={title} onChange={(e) => setTitle(e.target.value)} />

      {posts.map((post) => (
        <li key={post.id}>{post.title || post.name}</li>
      ))}

      {gotop && (
        <button
          style={{
            right: 0,
            bottom: 0,
            position: "fixed",
          }}
          onClick={() =>
            window.scrollTo({
              top: 0,
              behavior: "smooth"
            })
          }
        >
          Gotop
        </button>
      )}
    </div>
  );
}

export default Content;

22.  Dùng với timers : setInterval, setTimeout, clearInterval, clearTimeout
- Lưu ý khi dùng timers với mount thì nhớ return clear để tránh mem leak
VD1 : Chạy ngược
function Content() {
  const [countdown, setCountdown] = useState(180)

  useEffect(() => {
    setInterval(() => {
      setCountdown(pre => pre - 1)
    }, 1000)

    return () => clearInterval(timerId)
  }, [])

  return (
    <div>
      <h1>{countdown}</h1>
    </div>
  )
}

23. Preview Avatar 
VD2 :
function Content() {
  const [avatar, setAvatar] = useState();

  useEffect(() => {
    // Cleanup function: Handle khi người dùng pick ảnh khác (reset state), xoá ảnh cũ khỏi khay nhớ tạm
    return () => {
      avatar && URL.revokeObjectURL(avatar.preview);
    };
  }, [avatar]);

  const handlePreviewAvatar = (e) => {
    const file = e.target.files[0];

    // URL.createObjectURL tạo ra 1 URL cho ảnh, lấy file và set
    file.preview = URL.createObjectURL(file);

    setAvatar(file);

    e.target.avatar = null;
  };

  return (
    <div>
      <input type="file" onChange={handlePreviewAvatar} />
      {avatar && <img src={avatar.preview} alt="" width="50%" height="50%" />}
    </div>
  );
}

24 . useLayoutEffect
import { useLayoutEffect, useEffect, useState } from "react";
- useLayoutEffect gần giống useEffect, nên tất cả th thường sẽ dùng useEffect
- Dùng khi check điều kiện 
function Content() {
  const [count, setCount] = useState(0);

  const handleRun = () => {
    setCount(count + 1);
  };

  useLayoutEffect(() => {
    if (count > 3) setCount(0);
  }, [count]);

  return (
    <div>
      <h1>{count}</h1>
      <button onClick={handleRun}>Run</button>
    </div>
  );
}

25. useRef 
import { useRef, useLayoutEffect, useEffect, useState } from "react";
- Ref là refferent (Tham chiếu ) : Lưu các giá trị qua một tham chiếu bên ngoài
- Tác dụng : Biến chạy đồng bộ, Lấy dc element

export default function App() {

  const [count, setCount] = useState(60);

  let prevCount = useRef();
  const handleStoptoggle = useRef();
  let h1Ref = useRef();

  useEffect(() => {
    console.log(h1Ref.current) 
    // Chính là thẻ h1 , tương tự như các pthg get element khác
    // h1Ref.current.getBoundingClientRect() lấy toạ độ
  })

  useEffect(() => {
    prevCount.current = count;
  }, [count]);

  const handleStart = () => {
    handleStoptoggle.current = setInterval(() => {
      setCount((prev) => prev - 1);
    }, 1000);
  };

  const handleStop = () => {
    clearInterval(handleStoptoggle.current);
  };

  console.log(count + ", " + prevCount.current);

  return (
    <div className="App">
      <h1 ref = {h1Ref}>{count}</h1>
      <button onClick={handleStart}>Play </button>
      <button onClick={handleStop}>Stop</button>
    </div>
  );
}

25. React.memo()
- Là Higher Order Component (HOC)
- Hooks (Dùng trong Func Component), HOC, render props đều là phương thức
- Dùng để ghi nhớ lại component, tránh render không cần thiết tốn hiệu năng
- Check props truyền vào component nếu thay đổi thì được render ko thì thôi
- Dùng so sánh bằng toán tử ===

import React from 'react'
export default React.memo(Content)

import { memo } from "react"
export default memo(Content)

26. useCallback()
import { useCallback } from "react"
- Tránh tạo ra hàm mới không cần thiết
<>
  Cú pháp short-hand Fragment
</>

Chờ : onIncrease,
Thực hiện : handleIncrease

const handleIncrease = useCallback(() => {
  setCount(pre => pre + 1 )
}, [])

- Dependencies không đổi thì trả lại tham chiếu trước đó
- Chỉ dùng useCallback khi dùng memo

27. useMemo 
- là hooks nên dùng trong function component
- Dùng để tránh thực hiện logic nào đó không cần thiết

import { useMemo } from "react"
import { useState, useRef, useMemo } from "react";

function App() {
  const [name, setName] = useState("");
  const [price, setPrice] = useState("");
  const [products, setProducts] = useState([]);

  const nameInput = useRef();

  const handleSubmit = () => {
    setProducts((prev) => {
      return [...prev, { name, price: +price }];
    });
    setName("");
    setPrice("");
    nameInput.current.focus();
  };

  const total = useMemo(() => {
    const result = products.reduce(
      (result, product) => result + product.price,
      0
    );
    return result;
  }, [products]);

  return (
    <div>
      <input
        ref={nameInput}
        placeholder="Enter Name ..."
        value={name}
        onChange={(e) => setName(e.target.value)}
      />
      <br />
      <input
        placeholder="Enter Price ..."
        value={price}
        onChange={(e) => setPrice(e.target.value)}
      />
      <br />
      <button onClick={handleSubmit}>Add</button>
      <br />
      Total: {total}
      <ul>
        {products.map((product, index) => (
          <li key={index}>
            {product.name} - {product.price}
          </li>
        ))}
      </ul>
    </div>
  );
}

28. useReducer()
import { useReducer } from "react"
- useState và useReducer có thể dùng thay thế cho nhau trong mọi trường hợp
Bc 1 : Init state
Bc 2 : Action
Bc 3 : Reducer 
Bc 4 : Dispatch

VD 1:

import "./styles.css";
import { useReducer } from "react";

const initCount = 0;
const UP_ACTION = "up";
const DOWN_ACTION = "down";

const reducer = (state, action) => {
  console.log("reducer");
  switch (action) {
    case UP_ACTION:
      return state + 1;
    case DOWN_ACTION:
      return state - 1;
    default:
      throw new Error("Invalid action");
  }
};

export default function App() {
  const [count, dispatch] = useReducer(reducer, initCount);
  return (
    <div>
      <h1>{count}</h1>
      <button onClick={() => dispatch(UP_ACTION)}>Up</button>
      <button onClick={() => dispatch(DOWN_ACTION)}>Down</button>
    </div>
  );
}

VD 2:
import { useState, useReducer, useRef } from "react";

const initState = {
  job: "",
  jobs: []
};

const SET_JOB = "set_job";
const ADD_JOB = "add_job";
const DELETE_JOB = "delete_job";

const setJob = (payload) => {
  return {
    type: SET_JOB,
    payload
  };
};

const addJob = (payload) => {
  return {
    type: ADD_JOB,
    payload
  };
};

const deleteJob = (payload) => {
  return {
    type: DELETE_JOB,
    payload
  };
};

const reducer = (state, action) => {
  switch (action.type) {
    case SET_JOB:
      return {
        ...state,
        job: action.payload
      };
    case ADD_JOB:
      return {
        ...state,
        jobs: [...state.jobs, action.payload]
      };
    case DELETE_JOB:
      state.jobs.splice(action.payload, 1);
      return {
        ...state
      };

    default:
      throw new Error("Invalid action.");
  }
};

function App() {
  const [state, dispatch] = useReducer(reducer, initState);
  const { job, jobs } = state;

  const inputRef = useRef();

  const handleSubmit = () => {
    dispatch(addJob(job));
    dispatch(setJob(""));
    inputRef.current.focus();
  };

  return (
    <div style={{ padding: "20px" }}>
      <h3>Todo</h3>
      <input
        ref={inputRef}
        value={job}
        placeholder="Enter todo..."
        onChange={(e) => {
          dispatch(setJob(e.target.value));
        }}
      ></input>
      <button onClick={handleSubmit}>Add</button>
      <ul>
        {jobs.map((job, index) => (
          <li key={index}>
            {job}
            <button
              onClick={() => {
                dispatch(deleteJob(index));
              }}
            >
              X
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
}

export default App;

29. useContext()
- Đơn giản hoá truyền dữ liệu từ component cha xuống component con
Bc 1 : create useContext
Bc 2 : Provider
Bc 3 : Consumer

// Tk gửi
import { createContext } from 'react' 

// Tk nhận
import { useContext } from 'react' 

30. Context + useReducer
- Để tạo global state
- Khó như chó ( Bài ví dụ trong tiktok )

So sánh Redux vs React-context :
 => Nên Redux ngon hơn so với React-context

31. useImperativeHandle()
- Hooks
- HOC : forwardRef (Component)

32. Sử dụng css trong react
- Trong dev evironment
import "./App.css" là sử dụng css internal ( viết css ở đầu trang )

- Trong production 
Nó lại là external gom hết file css thành 1 file do đó tránh đặt tên trùng gây css lẫn lộn

npm run build
serve -s build 

33. CSS module
- CSS module và styled component là 2 cách để tách css ra thành file riêng biệt
- Khi dùng CSS module thì dùng camelCase
- CSS module có ưu điểm :
  + Tách css ra ko bị trùng nhau
  + Khi ko import thì ko build css vào bản thương mại
Nhược :
  + Không thể dùng tag name do ko thể đổi tên nên vẫn áp dụng hết VD : p, *, h1, ...  vẫn áp dụng hết ko chia riêng

Bc 1 : Đổi tên file css thành .module ví dụ :
+ Paragraph.css -> Paragraph.module.css 
Bc 2: import 
import style from './Paragraph.module.css'
+ Trong đó style là Object có 2 key là tên các class Ví Dụ :
<p className = {style.paragraph} > XIN CHAO </p>

34. Clsx 
<p className = X > 
  XIN CHAO 
</p>

- Cách css 2 class thuần : Tạo thành chuỗi (string) cách nhau là dc
C1 : X = { [style.paragraph, style.active].join(' ') }
C2 : X = { `${style.paragraph} ${style.active}` }

- Hoặc dùng classNames (Cũ) hoặc clsx (Mới)
npm i clsx : Để cài clsx
C3 : X = { clsx(style.paragraph, style.active) }

- Hiển thị có điều kiện 
+ [style.active] là làm việc với obj học từ đầu 
+ [style.active] : true là hiển thị [style.active] : false là ko hiển thị

- 'd-flex' là class chung ko dùng module ở GlobalStyles
C4 :const classes =  clsx(style.paragraph, {
  'd-flex' : false ,
  [style.active] : active
})

X =  { classes }

35. Install SASS để dùng SCSS
npm i scss : Cần cài loader thay đổi webpack nên ctrl c đi chạy lại npm start là dc
Bc 1 : Đổi tên file từ X.module.css => X.module.scss
Bc 2 : Tự học scss : https://sass-lang.com/documentation/

36. React router dom
npm i react-router-dom

Khi cài npm i thêm -D thì sẽ chỉ cài trong phát triển
Thư mục root là ngang cấp src

           PHẦN II : TẠO Project TIKTOK

37. Tạo dự án :
Tạo GlobalStyles component
Cài thư viện SASS: npm i -D sass
Reset CSS : npm install --save normalize.css
Default CSS: font-family, font-size, line-height


38. Cấu hình Router/Layout cho dự án
Bc1 : Phân tích tổng quan latout tiktok
Bc2 : Cài react-router-dom : npm i react-router-dom
Bc3 : Đưa cấu hình routes ra ngoài
Bc4 : Xây dựng cơ chế tải Layout

Wrap :
Bc1 : Bôi đen code -> ctrl shift P -> Wrap

39. Dựng khung Layout mặc định
npm i classnames
- Dùng để khi viết - trong js vẫn ok
VD: styles.item-1 vẫn ok hoặc   
  function Header() {
    return <header className={cx('wrapper')}></header>
}
- Lưu ý: import classNames from 'classnames'; ko dùng được cần ghi chính import classNames from 'classnames/bind';

  index.js
import classNames from 'classnames/bind';
import styles from './Header.module.scss';

const cx = classNames.bind(styles)

function Header() {
    return <header className={cx('wrapper')}></header>
}